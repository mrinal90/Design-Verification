<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Path Coverage for Module : tx_dequeue</title>
<link type="text/css" rel="stylesheet" href=".urg.css">
<script type="text/javascript" src=".sortable.js"></script></head>
<body><center><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | <a href="groups.html" ><b>groups</b></a> | <a href="tests.html" ><b>tests</b></a> | asserts</center>
<br>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="modlist.html#tag_tx_dequeue" >tx_dequeue</a></span>
<br clear=all>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>PATH</td></tr><tr>
<td class="s5 cl rt"> 50.29</td>
<td class="s7 cl rt"><a href="mod2_Line.html" > 75.24</a></td>
<td class="s4 cl rt"><a href="mod2_Cond.html" > 44.44</a></td>
<td class="s9 cl rt"><a href="mod2_Toggle.html" > 92.23</a></td>
<td class="s3 cl rt"><a href="mod2_FSM.html" > 37.50</a></td>
<td class="s5 cl rt"><a href="mod2_Branch.html" > 52.17</a></td>
<td class="s0 cl rt"><a href="mod2_Path.html" >  0.16</a></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="file:///home/sf100212/SV_Project/sim/verilog/../../rtl/verilog/tx_dequeue.v" >/home/sf100212/SV_Project/sim/verilog/../../rtl/verilog/tx_dequeue.v</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left class="sml">
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>PATH</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s5 cl rt"> 50.29</td>
<td class="s7 cl rt"><a href="mod2_Line.html" > 75.24</a></td>
<td class="s4 cl rt"><a href="mod2_Cond.html" > 44.44</a></td>
<td class="s9 cl rt"><a href="mod2_Toggle.html" > 92.23</a></td>
<td class="s3 cl rt"><a href="mod2_FSM.html" > 37.50</a></td>
<td class="s5 cl rt"><a href="mod2_Branch.html" > 52.17</a></td>
<td class="s0 cl rt"><a href="mod2_Path.html" >  0.16</a></td>
<td><a href="mod2_2.html" >tb.dut.tx_dq0</a></td>
</tr></table></div>
<br clear=all>
<hr>
Path Coverage for Module : <a href="mod2.html" >tx_dequeue</a><br clear=all>
<table class="rt">
<col width="122">
<col span="4" width="82">
<tr><th><th>Line No.<th>Total<th>Covered<th>Percent
<tr class="s0"><td class="lf">Paths<td><td>15554<td>25<td>0.16
<tr class="s5"><td><td>181<td>4<td>2<td>50.00
<tr class="s4"><td><td>222<td>5<td>2<td>40.00
<tr class="s0"><td><td>297<td>15468<td>8<td>0.05
<tr class="s1"><td><td>707<td>28<td>4<td>14.29
<tr class="s1"><td><td>826<td>49<td>9<td>18.37
</table>
<br><pre class="code">
181         always @(posedge clk_xgmii_tx or negedge reset_xgmii_tx_n) begin
182         
183             if (reset_xgmii_tx_n == 1'b0) begin
                -1-
184         
185                 xgmii_txd &lt;= {8{`IDLE}};
186                 xgmii_txc &lt;= 8'hff;
187         
188             end
189             else begin
190         
191         
192                 //---
193                 // RC Layer, insert local or remote fault messages based on status
194                 // of fault state-machine
195         
196                 if (status_local_fault_ctx) begin
                    -2-
197         
198                     // If local fault detected, send remote fault message to
199                     // link partner
200                     
201                     xgmii_txd &lt;= {`REMOTE_FAULT, 8'h0, 8'h0, `SEQUENCE,
202                                   `REMOTE_FAULT, 8'h0, 8'h0, `SEQUENCE};
203                     xgmii_txc &lt;= {4'b0001, 4'b0001};
204                 end
205                 else if (status_remote_fault_ctx) begin
                         -3-
</pre>
<b>Paths:</b><br>
<table class="ct">
<col span="3" width="25">
<tr><th>-1-<th>-2-<th>-3-<th>Status
<tr class="uRed"><td>0<td>1<td>-<td class="lf">Not Covered
<tr class="uGreen"><td>0<td>0<td>0<td class="lf">Covered
<tr class="uRed"><td>0<td>0<td>1<td class="lf">Not Covered
<tr class="uGreen"><td>1<td>-<td>-<td class="lf">Covered
</table>
<br><pre class="code">
222         always @(posedge clk_xgmii_tx or negedge reset_xgmii_tx_n) begin
223         
224             if (reset_xgmii_tx_n == 1'b0) begin
                -1-
225         
226                 curr_state_enc &lt;= SM_IDLE;
227         
228                 start_on_lane0 &lt;= 1'b1;
229                 ifg_deficit &lt;= 3'b0;
230                 ifg_4b_add &lt;= 1'b0;
231                 ifg_8b_add &lt;= 1'b0;
232                 ifg_8b2_add &lt;= 1'b0;
233         
234                 eop &lt;= 8'b0;
235         
236                 txhfifo_rdata_d1 &lt;= 64'b0;
237         
238                 xgxs_txd_barrel &lt;= {4{`IDLE}};
239                 xgxs_txc_barrel &lt;= 4'hf;
240         
241                 frame_available &lt;= 1'b0;
242         
243                 xgxs_txd &lt;= {8{`IDLE}};
244                 xgxs_txc &lt;= 8'hff;
245         
246                 status_txdfifo_udflow_tog &lt;= 1'b0;
247         
248             end
249             else begin
250         
251                 curr_state_enc &lt;= next_state_enc;
252         
253                 start_on_lane0 &lt;= next_start_on_lane0;
254                 ifg_deficit &lt;= next_ifg_deficit;
255                 ifg_4b_add &lt;= next_ifg_4b_add;
256                 ifg_8b_add &lt;= next_ifg_8b_add;
257                 ifg_8b2_add &lt;= next_ifg_8b2_add;
258         
259                 eop &lt;= next_eop;
260         
261                 txhfifo_rdata_d1 &lt;= txhfifo_rdata;
262         
263                 xgxs_txd_barrel &lt;= next_xgxs_txd[63:32];
264                 xgxs_txc_barrel &lt;= next_xgxs_txc[7:4];
265         
266                 frame_available &lt;= next_frame_available;
267         
268                 //---
269                 // Barrel shifter. Previous stage always align packet with LANE0.
270                 // This stage allow us to shift packet to align with LANE4 if needed
271                 // for correct inter frame gap (IFG).
272         
273                 if (next_start_on_lane0) begin
                    -2-
274         
275                     xgxs_txd &lt;= next_xgxs_txd;
276                     xgxs_txc &lt;= next_xgxs_txc;
277         
278                 end
279                 else begin
280         
281                     xgxs_txd &lt;= {next_xgxs_txd[31:0], xgxs_txd_barrel};
282                     xgxs_txc &lt;= {next_xgxs_txc[3:0], xgxs_txc_barrel};
283         
284                 end
285         
286                 //---
287                 // FIFO errors, used to generate interrupts.
288                 
289                 if (txdfifo_ren &amp;&amp; txdfifo_rempty) begin
                    -3-
</pre>
<b>Paths:</b><br>
<table class="ct">
<col span="3" width="25">
<tr><th>-1-<th>-2-<th>-3-<th>Status
<tr class="uRed"><td>0<td>0<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>1<td class="lf">Not Covered
<tr class="uGreen"><td>0<td>1<td>0<td class="lf">Covered
<tr class="uRed"><td>0<td>1<td>1<td class="lf">Not Covered
<tr class="uGreen"><td>1<td>-<td>-<td class="lf">Covered
</table>
<br><pre class="code">
297         always @(/*AS*/crc32_tx or ctrl_tx_enable_ctx or curr_state_enc or eop
298                  or frame_available or ifg_4b_add or ifg_8b2_add or ifg_8b_add
299                  or ifg_deficit or start_on_lane0 or status_local_fault_ctx
300                  or txhfifo_ralmost_empty or txhfifo_rdata_d1
301                  or txhfifo_rempty or txhfifo_rstatus) begin
302         
303             next_state_enc = curr_state_enc;
304         
305             next_start_on_lane0 = start_on_lane0;
306             next_ifg_deficit = ifg_deficit;
307             next_ifg_4b_add = ifg_4b_add;
308             next_ifg_8b_add = ifg_8b_add;
309             next_ifg_8b2_add = ifg_8b2_add;
310         
311             next_eop = eop;
312         
313             next_xgxs_txd = {8{`IDLE}};
314             next_xgxs_txc = 8'hff;
315         
316             txhfifo_ren = 1'b0;
317         
318             next_frame_available = frame_available;
319         
320             case (curr_state_enc)
                -1-
321         
322                 SM_IDLE:
323                   begin
324         
325                       // Wait for frame to be available. There should be a least N bytes in the
326                       // data fifo or a crc in the control fifo. The N bytes in the data fifo
327                       // give time to the enqueue engine to calculate crc and write it to the
328                       // control fifo. If crc is already in control fifo we can start transmitting
329                       // with no concern. Transmission is inhibited if local or remote faults
330                       // are detected.
331         
332                       if (ctrl_tx_enable_ctx &amp;&amp; frame_available &amp;&amp;
                          -2-
333                           !status_local_fault_ctx &amp;&amp; !status_local_fault_ctx) begin
334         
335                           txhfifo_ren = 1'b1;
336                           next_state_enc = SM_PREAMBLE;
337         
338                       end
339                       else begin
340         
341                           next_frame_available = !txhfifo_ralmost_empty;
342                           next_ifg_4b_add = 1'b0;
343         
344                       end
345         
346                   end
347         
348                 SM_PREAMBLE:
349                  begin
350         
351                      // On reading SOP from fifo, send SFD and preamble characters
352         
353                      if (txhfifo_rstatus[`TXSTATUS_SOP]) begin
                         -3-
354         
355                          next_xgxs_txd = {`SFD, {6{`PREAMBLE}}, `START};
356                          next_xgxs_txc = 8'h01;
357         
358                          txhfifo_ren = 1'b1;
359         
360                          next_state_enc = SM_TX;
361         
362                      end
363                      else begin
364         
365                          next_frame_available = 1'b0;
366                          next_state_enc = SM_IDLE;
367         
368                      end
369         
370         
371                      // Depending on deficit idle count calculations, add 4 bytes
372                      // or IFG or not. This will determine on which lane start the
373                      // next frame.
374                      
375                      if (ifg_4b_add) begin
                         -4-
376                          next_start_on_lane0 = 1'b0;
377                      end
378                      else begin
379                          next_start_on_lane0 = 1'b1;
380                      end
381         
382                   end
383         
384                 SM_TX:
385                   begin
386         
387                       next_xgxs_txd = txhfifo_rdata_d1;
388                       next_xgxs_txc = 8'h00;
389         
390                       txhfifo_ren = 1'b1;
391         
392         
393                       // Wait for EOP indication to be read from the fifo, then
394                       // transition to next state.
395         
396                       if (txhfifo_rstatus[`TXSTATUS_EOP]) begin
                          -5-
397                           
398                           txhfifo_ren = 1'b0;
399                           next_frame_available = !txhfifo_ralmost_empty;
400                           next_state_enc = SM_EOP;
401         
402                       end
403                       else if (txhfifo_rempty || txhfifo_rstatus[`TXSTATUS_SOP]) begin
                               -6-
404         
405                           // Failure condition, we did not see EOP and there
406                           // is no more data in fifo or SOP, force end of packet transmit.
407         
408                           next_state_enc = SM_TERM_FAIL;
409         
410                       end
411         
412                       next_eop[0] = txhfifo_rstatus[2:0] == 3'd1;
413                       next_eop[1] = txhfifo_rstatus[2:0] == 3'd2;
414                       next_eop[2] = txhfifo_rstatus[2:0] == 3'd3;
415                       next_eop[3] = txhfifo_rstatus[2:0] == 3'd4;
416                       next_eop[4] = txhfifo_rstatus[2:0] == 3'd5;
417                       next_eop[5] = txhfifo_rstatus[2:0] == 3'd6;
418                       next_eop[6] = txhfifo_rstatus[2:0] == 3'd7;
419                       next_eop[7] = txhfifo_rstatus[2:0] == 3'd0;
420                         
421                   end
422         
423                 SM_EOP:
424                   begin
425         
426                       // Insert TERMINATE character in correct lane depending on position
427                       // of EOP read from fifo. Also insert CRC read from control fifo.
428         
429                       if (eop[0]) begin
                          -7-
430                           next_xgxs_txd = {{2{`IDLE}}, `TERMINATE, 
431                                            crc32_tx[31:0], txhfifo_rdata_d1[7:0]};
432                           next_xgxs_txc = 8'b11100000;
433                       end
434         
435                       if (eop[1]) begin
                          -8-
436                           next_xgxs_txd = {`IDLE, `TERMINATE,
437                                            crc32_tx[31:0], txhfifo_rdata_d1[15:0]};
438                           next_xgxs_txc = 8'b11000000;
439                       end
440         
441                       if (eop[2]) begin
                          -9-
442                           next_xgxs_txd = {`TERMINATE, crc32_tx[31:0], txhfifo_rdata_d1[23:0]};
443                           next_xgxs_txc = 8'b10000000;
444                       end
445         
446                       if (eop[3]) begin
                          -10-
447                           next_xgxs_txd = {crc32_tx[31:0], txhfifo_rdata_d1[31:0]};
448                           next_xgxs_txc = 8'b00000000;
449                       end
450         
451                       if (eop[4]) begin
                          -11-
452                           next_xgxs_txd = {crc32_tx[23:0], txhfifo_rdata_d1[39:0]};
453                           next_xgxs_txc = 8'b00000000;
454                       end
455         
456                       if (eop[5]) begin
                          -12-
457                           next_xgxs_txd = {crc32_tx[15:0], txhfifo_rdata_d1[47:0]};
458                           next_xgxs_txc = 8'b00000000;
459                       end
460         
461                       if (eop[6]) begin
                          -13-
462                           next_xgxs_txd = {crc32_tx[7:0], txhfifo_rdata_d1[55:0]};
463                           next_xgxs_txc = 8'b00000000;
464                       end
465         
466                       if (eop[7]) begin
                          -14-
467                           next_xgxs_txd = {txhfifo_rdata_d1[63:0]};
468                           next_xgxs_txc = 8'b00000000;
469                       end
470         
471                       if (!frame_available) begin
                          -15-
472         
473                           // If there is not another frame ready to be transmitted, interface
474                           // will go idle and idle deficit idle count calculation is irrelevant.
475                           // Set deficit to 0.
476                           
477                           next_ifg_deficit = 3'b0;
478         
479                       end
480                       else begin
481         
482                           // Idle deficit count calculated based on number of &quot;wasted&quot; bytes
483                           // between TERMINATE and alignment of next frame in LANE0.
484         
485                           next_ifg_deficit = ifg_deficit +
486                                              {2'b0, eop[0] | eop[4]} +
487                                              {1'b0, eop[1] | eop[5], 1'b0} +
488                                              {1'b0, eop[2] | eop[6],
489                                               eop[2] | eop[6]};
490                       end
491         
492                       // IFG corrections based on deficit count and previous starting lane
493                       // Calculated based on following table:
494                       //
495                       //                 DIC=0          DIC=1          DIC=2          DIC=3
496                       //              -------------  -------------  -------------  -------------
497                       // PktLen       IFG      Next  IFG      Next  IFG      Next  IFG      Next
498                       // Modulus      Length   DIC   Length   DIC   Length   DIC   Length   DIC
499                       // -----------------------------------------------------------------------
500                       //    0           12      0      12      1      12      2      12      3
501                       //    1           11      1      11      2      11      3      15      0
502                       //    2           10      2      10      3      14      0      14      1
503                       //    3            9      3      13      0      13      1      13      2
504                       //
505                       //
506                       // In logic it translates into adding 4, 8, or 12 bytes of IFG relative
507                       // to LANE0.
508                       //   IFG and Add columns assume no deficit applied
509                       //   IFG+DIC and Add+DIC assume deficit must be applied
510                       //
511                       //                        Start lane 0       Start lane 4    
512                       // EOP Pads IFG  IFG+DIC    Add   Add+DIC       Add    Add IFG
513                       // 0   3    11   15        8     12           12     16
514                       // 1   2    10   14        8     12           12     16
515                       // 2   1    9    13        8     12           12     16
516                       // 3   8    12   12        4     4            8      8
517                       // 4   7    11   15        4     8            8      12
518                       // 5   6    10   14        4     8            8      12
519                       // 6   5    9    13        4     8            8      12
520                       // 7   4    12   12        8     8            12     12
521         
522                       if (!frame_available) begin
                          -16-
523         
524                           // If there is not another frame ready to be transmitted, interface
525                           // will go idle and idle deficit idle count calculation is irrelevant.
526                           
527                           next_ifg_4b_add = 1'b0;
528                           next_ifg_8b_add = 1'b0;
529                           next_ifg_8b2_add = 1'b0;
530         
531                       end
532                       else if (next_ifg_deficit[2] == ifg_deficit[2]) begin
                               -17-
533         
534                           // Add 4 bytes IFG
535                           
536                           next_ifg_4b_add = (eop[0] &amp; !start_on_lane0) |
537                                             (eop[1] &amp; !start_on_lane0) |
538                                             (eop[2] &amp; !start_on_lane0) |
539                                             (eop[3] &amp; start_on_lane0) |
540                                             (eop[4] &amp; start_on_lane0) |
541                                             (eop[5] &amp; start_on_lane0) |
542                                             (eop[6] &amp; start_on_lane0) |
543                                             (eop[7] &amp; !start_on_lane0);
544         
545                           // Add 8 bytes IFG
546                           
547                           next_ifg_8b_add = (eop[0]) |
548                                             (eop[1]) |
549                                             (eop[2]) |
550                                             (eop[3] &amp; !start_on_lane0) |
551                                             (eop[4] &amp; !start_on_lane0) |
552                                             (eop[5] &amp; !start_on_lane0) |
553                                             (eop[6] &amp; !start_on_lane0) |
554                                             (eop[7]);
555         
556                           // Add another 8 bytes IFG
557         
558                           next_ifg_8b2_add = 1'b0;
559         
560                       end
561                       else begin
562         
563                           // Add 4 bytes IFG
564         
565                           next_ifg_4b_add = (eop[0] &amp; start_on_lane0) |
566                                             (eop[1] &amp; start_on_lane0) |
567                                             (eop[2] &amp; start_on_lane0) |
568                                             (eop[3] &amp;  start_on_lane0) |
569                                             (eop[4] &amp; !start_on_lane0) |
570                                             (eop[5] &amp; !start_on_lane0) |
571                                             (eop[6] &amp; !start_on_lane0) |
572                                             (eop[7] &amp; !start_on_lane0);
573         
574                           // Add 8 bytes IFG
575                           
576                           next_ifg_8b_add = (eop[0]) |
577                                             (eop[1]) |
578                                             (eop[2]) |
579                                             (eop[3] &amp; !start_on_lane0) |
580                                             (eop[4]) |
581                                             (eop[5]) |
582                                             (eop[6]) |
583                                             (eop[7]);
584         
585                           // Add another 8 bytes IFG
586         
587                           next_ifg_8b2_add = (eop[0] &amp; !start_on_lane0) |
588                                              (eop[1] &amp; !start_on_lane0) |
589                                              (eop[2] &amp; !start_on_lane0);
590         
591                       end
592         
593                       if (|eop[2:0]) begin
                          -18-
594         
595                           if (frame_available) begin
                              -19-
596         
597                               // Next state depends on number of IFG bytes to be inserted.
598                               // Skip idle state if needed.
599         
600                               if (next_ifg_8b2_add) begin
                                  -20-
601                                   next_state_enc = SM_IFG;
602                               end
603                               else if (next_ifg_8b_add) begin
                                       -21-
604                                   next_state_enc = SM_IDLE;
605                               end
606                               else begin
607                                   txhfifo_ren = 1'b1;
608                                   next_state_enc = SM_PREAMBLE;
609                               end
610         
611                           end
612                           else begin
613                               next_state_enc = SM_IFG;
614                           end
615                       end
616         
617                       if (|eop[7:3]) begin
                          -22-
618                           next_state_enc = SM_TERM;
619                       end
620         
621                   end
622         
623                 SM_TERM:
624                   begin
625         
626                       // Insert TERMINATE character in correct lane depending on position
627                       // of EOP read from fifo. Also insert CRC read from control fifo.
628         
629                       if (eop[3]) begin
                          -23-
630                           next_xgxs_txd = {{7{`IDLE}}, `TERMINATE};
631                           next_xgxs_txc = 8'b11111111;
632                       end
633         
634                       if (eop[4]) begin
                          -24-
635                           next_xgxs_txd = {{6{`IDLE}}, `TERMINATE, crc32_tx[31:24]};
636                           next_xgxs_txc = 8'b11111110;
637                       end
638         
639                       if (eop[5]) begin
                          -25-
640                           next_xgxs_txd = {{5{`IDLE}}, `TERMINATE, crc32_tx[31:16]};
641                           next_xgxs_txc = 8'b11111100;
642                       end
643         
644                       if (eop[6]) begin
                          -26-
645                           next_xgxs_txd = {{4{`IDLE}}, `TERMINATE, crc32_tx[31:8]};
646                           next_xgxs_txc = 8'b11111000;
647                       end
648         
649                       if (eop[7]) begin
                          -27-
650                           next_xgxs_txd = {{3{`IDLE}}, `TERMINATE, crc32_tx[31:0]};
651                           next_xgxs_txc = 8'b11110000;
652                       end
653         
654                       // Next state depends on number of IFG bytes to be inserted.
655                       // Skip idle state if needed.
656         
657                       if (frame_available &amp;&amp; !ifg_8b_add) begin
                          -28-
658                           txhfifo_ren = 1'b1;
659                           next_state_enc = SM_PREAMBLE;
660                       end
661                       else if (frame_available) begin
                               -29-
</pre>
<b>Paths:</b><br>
Uncovered paths are not available because they are not computed at compile time when there are more than 50 paths in the block.<br>
<table class="lf sml"><th>Path<th>Status
<tr class="uGreen"><td>(1, SM_IDLE)-&gt;(2)<td>Covered
<tr class="uGreen"><td>(1, SM_IDLE)-&gt;!(2)<td>Covered
<tr class="uGreen"><td>(1, SM_PREAMBLE)-&gt;(3)-&gt;!(4)<td>Covered
<tr class="uGreen"><td>(1, SM_TX)-&gt;(5)<td>Covered
<tr class="uGreen"><td>(1, SM_TX)-&gt;!(5)-&gt;!(6)<td>Covered
<tr class="uGreen"><td>(1, SM_EOP)-&gt;!(7)-&gt;!(8)-&gt;!(9)-&gt;!(10)-&gt;!(11)-&gt;!(12)-&gt;!(13)-&gt;(14)-&gt;(15)-&gt;(16)-&gt;!(18)-&gt;(22)<td>Covered
<tr class="uGreen"><td>(1, SM_TERM)-&gt;!(23)-&gt;!(24)-&gt;!(25)-&gt;!(26)-&gt;(27)-&gt;!(28)-&gt;!(29)<td>Covered
<tr class="uGreen"><td>(1, SM_IFG)<td>Covered
</table>
<br><pre class="code">
707         always @(/*AS*/byte_cnt or curr_state_pad or txdfifo_rdata
708                  or txdfifo_rempty or txdfifo_ren_d1 or txdfifo_rstatus
709                  or txhfifo_walmost_full) begin
710         
711             next_state_pad = curr_state_pad;
712         
713             next_txhfifo_wdata = txdfifo_rdata;
714             next_txhfifo_wstatus = txdfifo_rstatus;
715         
716             txdfifo_ren = 1'b0;
717             next_txhfifo_wen = 1'b0;
718         
719             case (curr_state_pad)
                -1-
720         
721               SM_PAD_EQ: begin
722         
723         
724                   //---
725                   // If room availabe in hoding fifo and data available in
726                   // data fifo, transfer data words. If transmit state machine
727                   // is reading from fifo we can assume room will be available.
728         
729                   if (!txhfifo_walmost_full) begin
                      -2-
730         
731                       txdfifo_ren = !txdfifo_rempty;
732         
733                   end
734         
735         
736                   //---
737                   // This logic dependent on read during previous cycle.
738         
739                   if (txdfifo_ren_d1) begin
                      -3-
740         
741                       next_txhfifo_wen = 1'b1;
742         
743                       // On EOP, decide if padding is required for this packet.
744         
745                       if (txdfifo_rstatus[`TXSTATUS_EOP]) begin
                          -4-
746         
747                           if (byte_cnt &lt; 14'd56) begin
                              -5-
748         
749                               next_txhfifo_wstatus = `TXSTATUS_NONE;
750                               txdfifo_ren = 1'b0;
751                               next_state_pad = SM_PAD_PAD;
752         
753                           end
754                           else if (byte_cnt == 14'd56 &amp;&amp;
                                   -6-
755                                    (txdfifo_rstatus[2:0] == 3'd1 ||
756                                     txdfifo_rstatus[2:0] == 3'd2 ||
757                                     txdfifo_rstatus[2:0] == 3'd3)) begin
758         
759                               // Pad up to LANE3, keep the other 4 bytes for crc that will
760                               // be inserted by dequeue engine.
761                               
762                               next_txhfifo_wstatus[2:0] = 3'd4;
763         
764                               // Pad end bytes with zeros.
765         
766                               if (txdfifo_rstatus[2:0] == 3'd1)
                                  -7-
767                                 next_txhfifo_wdata[31:8] = 24'b0;
768                               if (txdfifo_rstatus[2:0] == 3'd2)
                                  -8-
769                                 next_txhfifo_wdata[31:16] = 16'b0;
770                               if (txdfifo_rstatus[2:0] == 3'd3)
                                  -9-
771                                 next_txhfifo_wdata[31:24] = 8'b0;
772         
773                               txdfifo_ren = 1'b0;
774         
775                           end
776                           else begin
777         
778                               txdfifo_ren = 1'b0;
779                                  
780                           end
781         
782                       end
783                 
784                   end
785         
786               end
787         
788               SM_PAD_PAD: begin
789         
790                   //---
791                   // Pad packet to 64 bytes by writting zeros to holding fifo.
792         
793                   if (!txhfifo_walmost_full) begin
                      -10-
794         
795                       next_txhfifo_wdata = 64'b0;
796                       next_txhfifo_wstatus = `TXSTATUS_NONE;
797                       next_txhfifo_wen = 1'b1;
798                       
799                       if (byte_cnt == 14'd56) begin
                          -11-
</pre>
<b>Paths:</b><br>
<table class="ct">
<col span="11" width="25">
<tr><th>-1-<th>-2-<th>-3-<th>-4-<th>-5-<th>-6-<th>-7-<th>-8-<th>-9-<th>-10-<th>-11-<th>Status
<tr class="uRed"><td>default<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_PAD<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>1<td>0<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_PAD<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>1<td>1<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_PAD<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>0<td>-<td class="lf">Not Covered
<tr class="uGreen"><td>SM_PAD_EQ<td>0<td>0<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td class="lf">Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>0<td>1<td>0<td>0<td>1<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>0<td>1<td>0<td>0<td>0<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>0<td>1<td>0<td>1<td>1<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>0<td>1<td>0<td>1<td>0<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>0<td>1<td>1<td>0<td>1<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>0<td>1<td>1<td>0<td>0<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>0<td>1<td>1<td>1<td>1<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>0<td>1<td>1<td>1<td>0<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>0<td>0<td>-<td>-<td>-<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>1<td>1<td>-<td>-<td>-<td>-<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>0<td>1<td>0<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td class="lf">Not Covered
<tr class="uGreen"><td>SM_PAD_EQ<td>1<td>0<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td class="lf">Covered
<tr class="uRed"><td>SM_PAD_EQ<td>1<td>1<td>1<td>0<td>1<td>0<td>0<td>1<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>1<td>1<td>1<td>0<td>1<td>0<td>0<td>0<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>1<td>1<td>1<td>0<td>1<td>0<td>1<td>1<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>1<td>1<td>1<td>0<td>1<td>0<td>1<td>0<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>1<td>1<td>1<td>0<td>1<td>1<td>0<td>1<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>1<td>1<td>1<td>0<td>1<td>1<td>0<td>0<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>1<td>1<td>1<td>0<td>1<td>1<td>1<td>1<td>-<td>-<td class="lf">Not Covered
<tr class="uRed"><td>SM_PAD_EQ<td>1<td>1<td>1<td>0<td>1<td>1<td>1<td>0<td>-<td>-<td class="lf">Not Covered
<tr class="uGreen"><td>SM_PAD_EQ<td>1<td>1<td>1<td>0<td>0<td>-<td>-<td>-<td>-<td>-<td class="lf">Covered
<tr class="uRed"><td>SM_PAD_EQ<td>1<td>1<td>1<td>1<td>-<td>-<td>-<td>-<td>-<td>-<td class="lf">Not Covered
<tr class="uGreen"><td>SM_PAD_EQ<td>1<td>1<td>0<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td class="lf">Covered
</table>
<br><pre class="code">
826         always @(posedge clk_xgmii_tx or negedge reset_xgmii_tx_n) begin
827         
828             if (reset_xgmii_tx_n == 1'b0) begin
                -1-
829         
830                 curr_state_pad &lt;= SM_PAD_EQ;
831         
832                 txdfifo_ren_d1 &lt;= 1'b0;
833         
834                 txhfifo_wdata &lt;= 64'b0;
835                 txhfifo_wstatus &lt;= 8'b0;
836                 txhfifo_wen &lt;= 1'b0;   
837         
838                 byte_cnt &lt;= 14'b0;
839         
840                 shift_crc_data &lt;= 64'b0;
841                 shift_crc_eop &lt;= 4'b0;
842                 shift_crc_cnt &lt;= 4'b0;
843         
844             end
845             else begin
846         
847                 curr_state_pad &lt;= next_state_pad;
848         
849                 txdfifo_ren_d1 &lt;= txdfifo_ren;
850         
851                 txhfifo_wdata &lt;= next_txhfifo_wdata;
852                 txhfifo_wstatus &lt;= next_txhfifo_wstatus;
853                 txhfifo_wen &lt;= next_txhfifo_wen;
854         
855         
856                 //---
857                 // Reset byte count on SOP
858                 
859                 if (next_txhfifo_wen) begin
                    -2-
860         
861                     if (next_txhfifo_wstatus[`TXSTATUS_SOP]) begin
                        -3-
862         
863                         byte_cnt &lt;= 14'd8;
864         
865                     end
866                     else begin
867         
868                         byte_cnt &lt;= byte_cnt + 14'd8;
869         
870                     end
871         
872                 end
873         
874         
875                 //---
876                 // Calculate CRC as data is written to holding fifo. The holding fifo creates
877                 // a delay that allow the CRC calculation to complete before the end of the frame
878                 // is ready to be transmited.
879         
880                 if (txhfifo_wen) begin
                    -4-
881         
882                     crc32_d64 &lt;= nextCRC32_D64(reverse_64b(txhfifo_wdata), crc_data);
883         
884                 end
885         
886                 if (txhfifo_wen &amp;&amp; txhfifo_wstatus[`TXSTATUS_EOP]) begin
                    -5-
887         
888                     // Last bytes calculated 8-bit at a time instead of 64-bit. Start
889                     // this process at the end of the frame.
890              
891                     crc32_d8 &lt;= crc32_d64;
892         
893                     shift_crc_data &lt;= txhfifo_wdata;
894                     shift_crc_cnt &lt;= 4'd9;
895         
896                     if (txhfifo_wstatus[2:0] == 3'b0) begin
                        -6-
897                       shift_crc_eop &lt;= 4'd8;
898                     end
899                     else begin
900                         shift_crc_eop &lt;= {1'b0, txhfifo_wstatus[2:0]};
901                     end
902         
903                 end
904                 else if (shift_crc_eop != 4'b0) begin
                         -7-
905         
906                     // Complete crc calculation 8-bit at a time until finished. This can
907                     // be 1 to 8 bytes long.
908         
909                     crc32_d8 &lt;= nextCRC32_D8(reverse_8b(shift_crc_data[7:0]), crc32_d8);
910         
911                     shift_crc_data &lt;= {8'b0, shift_crc_data[63:8]};
912                     shift_crc_eop &lt;= shift_crc_eop - 4'd1;
913                 
914                 end
915         
916         
917                 //---
918                 // Update CRC register at the end of calculation. Always update after 8
919                 // cycles for deterministic results, even if a single byte was present in
920                 // last data word.
921                 
922                 if (shift_crc_cnt == 4'b1) begin
                    -8-
</pre>
<b>Paths:</b><br>
<table class="ct">
<col span="8" width="25">
<tr><th>-1-<th>-2-<th>-3-<th>-4-<th>-5-<th>-6-<th>-7-<th>-8-<th>Status
<tr class="uRed"><td>0<td>0<td>-<td>0<td>1<td>0<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>-<td>0<td>1<td>0<td>-<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>-<td>0<td>1<td>1<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>-<td>0<td>1<td>1<td>-<td>1<td class="lf">Not Covered
<tr class="uGreen"><td>0<td>0<td>-<td>0<td>0<td>-<td>0<td>0<td class="lf">Covered
<tr class="uGreen"><td>0<td>0<td>-<td>0<td>0<td>-<td>0<td>1<td class="lf">Covered
<tr class="uGreen"><td>0<td>0<td>-<td>0<td>0<td>-<td>1<td>0<td class="lf">Covered
<tr class="uRed"><td>0<td>0<td>-<td>0<td>0<td>-<td>1<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>-<td>1<td>1<td>0<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>-<td>1<td>1<td>0<td>-<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>-<td>1<td>1<td>1<td>-<td>0<td class="lf">Not Covered
<tr class="uGreen"><td>0<td>0<td>-<td>1<td>1<td>1<td>-<td>1<td class="lf">Covered
<tr class="uRed"><td>0<td>0<td>-<td>1<td>0<td>-<td>0<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>-<td>1<td>0<td>-<td>0<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>-<td>1<td>0<td>-<td>1<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>0<td>-<td>1<td>0<td>-<td>1<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>0<td>1<td>0<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>0<td>1<td>0<td>-<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>0<td>1<td>1<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>0<td>1<td>1<td>-<td>1<td class="lf">Not Covered
<tr class="uGreen"><td>0<td>1<td>1<td>0<td>0<td>-<td>0<td>0<td class="lf">Covered
<tr class="uGreen"><td>0<td>1<td>1<td>0<td>0<td>-<td>0<td>1<td class="lf">Covered
<tr class="uRed"><td>0<td>1<td>1<td>0<td>0<td>-<td>1<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>0<td>0<td>-<td>1<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>1<td>1<td>0<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>1<td>1<td>0<td>-<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>1<td>1<td>1<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>1<td>1<td>1<td>-<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>1<td>0<td>-<td>0<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>1<td>0<td>-<td>0<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>1<td>0<td>-<td>1<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>1<td>1<td>0<td>-<td>1<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>0<td>1<td>0<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>0<td>1<td>0<td>-<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>0<td>1<td>1<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>0<td>1<td>1<td>-<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>0<td>0<td>-<td>0<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>0<td>0<td>-<td>0<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>0<td>0<td>-<td>1<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>0<td>0<td>-<td>1<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>1<td>1<td>0<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>1<td>1<td>0<td>-<td>1<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>1<td>1<td>1<td>-<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>1<td>1<td>1<td>-<td>1<td class="lf">Not Covered
<tr class="uGreen"><td>0<td>1<td>0<td>1<td>0<td>-<td>0<td>0<td class="lf">Covered
<tr class="uGreen"><td>0<td>1<td>0<td>1<td>0<td>-<td>0<td>1<td class="lf">Covered
<tr class="uRed"><td>0<td>1<td>0<td>1<td>0<td>-<td>1<td>0<td class="lf">Not Covered
<tr class="uRed"><td>0<td>1<td>0<td>1<td>0<td>-<td>1<td>1<td class="lf">Not Covered
<tr class="uGreen"><td>1<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td class="lf">Covered
</table>
<br clear=all>
<hr>
<center><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | <a href="groups.html" ><b>groups</b></a> | <a href="tests.html" ><b>tests</b></a> | asserts</center>
<br>
<br clear=all>
<br clear=all>
<table align=center><tr><td class="s0 cl">0%
<td class="s1 cl">10%
<td class="s2 cl">20%
<td class="s3 cl">30%
<td class="s4 cl">40%
<td class="s5 cl">50%
<td class="s6 cl">60%
<td class="s7 cl">70%
<td class="s8 cl">80%
<td class="s9 cl">90%
<td class="s10 cl">100%</table></body>
</html>
